"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const dgram_1 = require("dgram");
const os_1 = require("os");
const ip_1 = require("ip");
const mixerStatus = require("./packets/mixer-status");
const cdjStatus = require("./packets/cdj-status");
const debug = require("debug");
const constants_1 = require("./constants");
const mac_address_1 = require("mac-address");
const rxjs_1 = require("rxjs");
const d = debug('pro-dj-link:virtual-cdj');
class VirtualCdj {
    constructor(networkDevice, device = 0x05) {
        this.device = device;
        this._bpm = new rxjs_1.BehaviorSubject(0);
        this._devices = new rxjs_1.BehaviorSubject([]);
        this.keepalive = () => {
            const name = Buffer.alloc(0x14);
            name.write('Virtual CDJ');
            const mac = mac_address_1.toBuffer(this.mac);
            const ip = Buffer.alloc(4);
            ip.writeUInt32BE(ip_1.toLong(this.ip), 0);
            const a = Buffer.from([
                0x01, 0x02, 0x00, 0x36, this.device, 0x01,
            ]);
            const b = Buffer.from([
                0x01, 0x00, 0x00, 0x00, 0x01, 0x00
            ]);
            const packet = Buffer.concat([
                constants_1.KEEP_ALIVE_HEADER,
                name,
                a,
                mac,
                ip,
                b
            ]);
            this.socket.send(packet, constants_1.ANNOUNCEMENT_PORT, this.broadcast, err => {
                if (err) {
                    console.error(err);
                }
                d('Send Keep Alive Packet');
            });
        };
        const interfaces = os_1.networkInterfaces();
        const addresses = interfaces[networkDevice];
        if (!addresses) {
            throw new Error('Invalid Network Device');
        }
        const [addr] = addresses
            .filter(({ family }) => family === 'IPv4');
        if (!addr) {
            throw new Error('Invalid Network Device');
        }
        const { broadcastAddress } = ip_1.subnet(addr.address, addr.netmask);
        this.broadcast = broadcastAddress;
        this.mac = addr.mac;
        this.ip = addr.address;
        this.socket = dgram_1.createSocket('udp4');
        this.socket.on('message', (data, remote) => {
            if (mixerStatus.test(data)) {
                const status = mixerStatus.parse(data);
                d(`Mixer Status ${status.device} (${status.name})`);
            }
            else if (cdjStatus.test(data)) {
                const status = cdjStatus.parse(data);
                d(`CDJ Status ${status.device} (${status.name})`);
                if (status.state.master) {
                    this._bpm.next(status.speed.current);
                }
                const current = this._devices.getValue()
                    .filter(({ device }) => device !== status.device);
                this._devices.next([...current, status]);
            }
            else {
                d(data);
            }
        });
        this.socket.on('error', err => {
            console.error(err);
            this.socket.close();
        });
        this.socket.on('listening', () => {
            this.socket.setBroadcast(true);
            this.socket.setMulticastTTL(128);
            setInterval(this.keepalive, 1500);
            const { address, port } = this.socket.address();
            d(`Virtual CDJ Running on ${address}:${port}`);
        });
        this.socket.bind({
            port: 50002
        });
    }
    get devices() {
        return this._devices.asObservable();
    }
    get bpm() {
        return this._bpm.asObservable();
    }
}
exports.VirtualCdj = VirtualCdj;
//# sourceMappingURL=virtual-cdj.js.map